************************************************
* Arithmetic Parser - by Andrew Sanger 3440468 *
*----------------------------------------------*
*         for Programming Project 1            *
*                  SP3 2016                    *
************************************************

PLEASE NOTE
-----------

This code is not final and can be changed if there are any issues with it. Please let me
know if there's anything that needs changing, I just used the C++ code as a basis, and went
from there.

Also, after testing this code out on different formulas I found that it tends to return
a low value most of the time (between 0 and 10).. This might not create very colourful
pictures. So I had an idea to alter the result so it always returns a value between 0 and 1,
and then that can be used to create a 0 - 255 value.. (NOTE I HAVENT IMPLEMENTED THIS) e.g.

	(int)((colour % 1) * 255)) yields:
	
	Red : 0.8621947437033233    -> 219    
	Green : 0.23129639403611665 -> 58
	Blue : 1.0348983055325582   -> 8

Let me know what you think..

I hope I haven't left anything out.

HOW TO USE - ARITHMETIC PARSER
------------------------------

The arithmetic parser takes a String as input and returns an ArithmeticNode object
as output. This object acts as the first or root node of a tree containing all Arithmetic
functions that will be called recursively upon a pixel's colour values.

The string contains a formula that is generated by the code, and the string format is
shown below this in the "STRING FORMAT" section.

To use the arithmetic parser, create a singleton instance of it using: 

	ParserInterface.getInstance()
	
If you wish to allow for testing text to be displayed in the console while using the parser
please use this function:

	ParserInterface.setTesting(true)
	
This will allow for easy bug checking..

To run the parser, call the following function:

	ParserInterface.getArithmetic( <insert string object here> )
	
This will return an ArithmeticNode object. It will also throw two possible custom Exceptions
relating to validity of the string which must be handled. The two possible exceptions are:

	InvalidArgumentException - This exception is thrown when an invalid argument is in the
		string. eg, examples of valid arguments are sin, cos, tan.. examples of invalid
		arguments are sine, cosine, tangent etc.
		
	IncorrectVariablesException - This exception is thrown when an argument has either 
		too many or not enough variables in the string. eg, the plus argument must have
		2 variables eg (plus x y), while sin has 1.
		
HOW TO USE - ARITHMETIC NODE
----------------------------

The arithmetic node that is returned by the parser consists of the first node of a tree containing 
all arithmetic created by the string. To use the node to work on pixel values, you must create
two PixelNodes, one for X and one for Y. Then send these objects to the arithmetic node using
the following functions:

	ArithmeticNode.operation(xPixel, yPixel) - carries out the contained arithmetic on all
		red, green and blue values in X and Y. Returns a PixelNode object containing all three
		returned red, green and blue values.
		
	ArithmeticNode.redOperation(xPixel, yPixel)
	ArithmeticNode.greenOperation(xPixel, yPixel)
	ArithmeticNode.blueOperation(xPixel, yPixel) - carries out the contained arithmetic on either
		the red, green or blue values of the passed X and Y objects. Returns a double value
		containing colour data.
		
The colour values used in this code range from 0 to 255.

HOW TO USE - PIXEL NODE
-----------------------

The pixel node contains red, green and blue values for the current X or Y pixel. To create a
pixel node use the following constructor:

	PixelNode node = new PixelNode(redValue, greenValue, blueValue)
	
The pixel node automatically changes values below 0 to their positive counterpart, and anything
over 255 to 255.. This ensures no out of control errors.

STRING FORMAT
-------------

The string format in this code follows a simple convention, there is 1 space between each part 
of the string. The first argument is not contained in brackets. e.g.

	plus ( mod ( sin x ) ( minus pi y ) )
	
The string can be of any size. And can consist of the following.

	1 VARIABLE ARGUMENTS eg ( sqrt x )
		sqrt - square root
		square - to the power of 2
		cube - to the power of 3
		sin - sine
		cos - cosine
		tan - tangent
		log - logarithm
		
	2 VARIABLE ARGUMENTS eg ( plus x y )
		plus - addition
		minus - subtraction
		times - multiplication
		div - division
		mod - modulus
		
	POSSIBLE VARIABLES ( minus pi rand ) or ( mod x y )
		x - uses the supplied xPixel object
		y - uses the supplied yPixel object
		rand - creates a PixelNode object full of random (0 - 255) numbers
		pi - creates a PixelNode object containing pi for RGB

The convention of the previous C++ imagene formulas was used.